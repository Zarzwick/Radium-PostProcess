#include <LightPathLoader.hpp>
#include <LightPathComponent.hpp>
#include <Core/Math/Ray.hpp>
#include <Core/Math/RayCast.hpp>
#include <Core/Mesh/MeshPrimitives.hpp>
#include <Core/Mesh/TriangleMesh.hpp>
#include <Engine/Renderer/Renderer.hpp>
#include <Engine/Renderer/Mesh/Mesh.hpp>
#include <Engine/Renderer/RenderObject/RenderObject.hpp>
#include <Engine/Renderer/RenderObject/RenderObjectManager.hpp>
#include <Engine/Renderer/Material/Material.hpp>
#include <Engine/Renderer/Material/BlinnPhongMaterial.hpp>
#include <QColor>

using namespace pbrt;
using namespace sample_path_file;
using namespace Ra;
using namespace Engine;
using namespace Core;
using namespace std;

namespace LightPathPlugin {
  LightPathLoader::LightPathLoader(const string& fileName,
                                   RenderObjectManager* ROManager,
                                   LightPathUI* widget) :
    PathLoaderC::PathLoaderC(fileName), m_ROManager (ROManager), m_widget (widget) {
    dataMatrix = (fftw_complex *) malloc(sizeImage * sizeof(fftw_complex));
    resultMatrix = (fftw_complex *) malloc(sizeImage * sizeof(fftw_complex));
  }
  
  LightPathLoader::~LightPathLoader() {
    free(dataMatrix);
    free(resultMatrix);
    free(fft_out);
    free(fft_out_shift);
  }

  void LightPathLoader::preLoadingProcess() {
    if (m_sphere != NULL && m_sphere->isVisible()) {
      Vector4f coordTransformed;
      sphereData.center = Vector3(0.f, 0.f, 0.f);
      coordTransformed = Vector4f(sphereData.center[0], sphereData.center[1], sphereData.center[2],
                                  1.f);
      coordTransformed = m_sphere->getTransformAsMatrix() * coordTransformed;
      sphereData.center = Vector3f(coordTransformed[0], coordTransformed[1], coordTransformed[2]);
    }
    for (unsigned int cpt = 0; cpt < sizeImage; ++cpt) {
      dataMatrix[cpt][0] = 0;
      dataMatrix[cpt][1] = 0;
    }
  }

  void LightPathLoader::inLoadingProcess(const PathEntry &path) {}
  
  void LightPathLoader::postLoadingProcess() {
    fft_out = (double *) malloc(sizeImage * sizeof(double));
    fft_out_shift = (double *) malloc(sizeImage * sizeof(double));
    fft2D(dataMatrix, resultMatrix, sizeEdgeImage, sizeEdgeImage);
    fftw_complex_abs(resultMatrix, fft_out, sizeImage);
    fft_shift(fft_out, fft_out_shift);
    fft_image(fft_out_shift);
    m_widget->on__spectrumPrint(QPixmap::fromImage(*qi, Qt::AutoColor)
                                .scaled(380, 380, Qt::IgnoreAspectRatio, Qt::FastTransformation));
  }

  void LightPathLoader::fft_shift(double* fft_out, double* fft_out_shift) {
    for (uint row = 0; row < sizeEdgeImage; ++row) {
      for (uint col = 0; col < sizeEdgeImage; ++col) {
        fft_out_shift[row * sizeEdgeImage + col] =
          fft_out[((row + (sizeEdgeImage / 2)) % sizeEdgeImage) * sizeEdgeImage
              + ((col + (sizeEdgeImage / 2)) % sizeEdgeImage)];
      }
    }
  }

  void LightPathLoader::fft_image(double *out) {
    double mini = out[0];
    double maxi = out[0];
    for (unsigned int cpt = 0; cpt < sizeImage; ++cpt) {
      if (out[cpt] > maxi) {
        maxi = out[cpt];
      }
      if (out[cpt] < mini) {
        mini = out[cpt];
      }
    }
    qi = new QImage(sizeEdgeImage, sizeEdgeImage, QImage::Format_Grayscale8);
    for (uint row = 0; row < sizeEdgeImage; ++row) {
      for (uint col = 0; col < sizeEdgeImage; ++col) {
        uint res = uint(((out[row * sizeEdgeImage + col] - mini) / (maxi - mini)) * 255);
        qi->setPixelColor(row, col, QColor(res, res, res));
      }
    }
  }
  
  void LightPathLoader::fftw_complex_abs(fftw_complex *matrix, double* out, int size) {
    for (uint cpt = 0; cpt < size; ++cpt) {
      out[cpt] = sqrt(matrix[cpt][0] * matrix[cpt][0] +
                      matrix[cpt][1] * matrix[cpt][1]);
    }
  }
  
  void LightPathLoader::fft2D(fftw_complex *f, fftw_complex *F, int width, int height) {
    fftw_plan p = fftw_plan_dft_2d(width, height, f, F, FFTW_FORWARD, FFTW_ESTIMATE);
    fftw_execute(p);
    fftw_destroy_plan(p);
  }
  
  void LightPathLoader::collectData(const PathEntry &path, Vector3 rayDir) {
    float cosTeta = rayDir.dot(Vector3(0, 0, 1));
    float cosPhi = rayDir.dot(Vector3(1, 0, 0));
    double dataY = isBeta ? (double) path.beta[1] : (double) path.L[1];
    int x = round((cosPhi + 1) * sizeEdgeImage / 2);
    int y = round((cosTeta + 1) * sizeEdgeImage / 2);
    dataMatrix[x * sizeEdgeImage + y][0] += dataY;
  }
  
  bool LightPathLoader::rayCasting(const PathEntry &path, array<Vector3, 3> triVertices) {
    int cpt = 0;
    Vector3 p1, p2, rayDir, pHit;
    Ray ray;
    Ray& rayRef = ray;
    vector<Scalar> hitsOut;
    vector<Scalar>& hitsRef = hitsOut;
    bool isHit;
    for (const VertexEntry& vertices : path.vertices) {
      p1 << vertices.v[0], vertices.v[1], vertices.v[2];
      if (cpt > 0) {
        rayDir = Vector3(p2 - p1).normalized();
        rayRef = Ray(p1, rayDir);
        if (m_sphere != NULL && m_sphere->isVisible()) {
          isHit = RayCast::vsSphere(rayRef, sphereData.center, sphereData.radius, hitsRef);
        }
        else {
          isHit = RayCast::vsTriangle(rayRef, triVertices[0], triVertices[1], triVertices[2], hitsRef);
        }
        if (isHit) {
          pHit = hitsRef.back() * rayDir;
          if (pHit.norm() <= Vector3(p2 - p1).norm() ||
              (m_sphere != NULL && m_sphere->isVisible() &&
               Vector3(p1 - sphereData.center).norm() <= sphereData.radius)) {
            collectData(path, rayDir);
            return true;
          }
        }
      }
      p2 = p1;
      ++cpt;
    }
    return false;
  }
 
  bool LightPathLoader::isSelected(const PathEntry &path) {
    array<Vector3, 3> triVertices;
    if (m_sphere != NULL && m_sphere->isVisible()) {
      return rayCasting(path, triVertices);
    }
    else if (pickingData.init) {
      for (unsigned int i = 0; i < pickingData.vertices.size();) {
        triVertices[0] = pickingData.vertices[i++];
        triVertices[1] = pickingData.vertices[i++];
        triVertices[2] = pickingData.vertices[i++];
        if (rayCasting(path, triVertices)) {
          return true;
        }
      }
    }
    return false;
  }
  
  void LightPathLoader::setPickResult(const Renderer::PickingResult pick) { 
    pickingData.m_roIdx = pick.m_roIdx;
    pickingData.m_mode = pick.m_mode;
    if (m_ROManager->exists(pickingData.m_roIdx)
        && (pickingData.m_mode == Renderer::PickingMode::TRIANGLE
            || pickingData.m_mode == Renderer::PickingMode::C_TRIANGLE)) {
      pickingData.init = true;
      shared_ptr<RenderObject> ro = m_ROManager->getRenderObject(pickingData.m_roIdx);
      Vector3ui triangle;
      pickingData.vertices.clear();
      for (auto it = pick.m_elementIdx.cbegin(); it != pick.m_elementIdx.cend(); ++it) {
        triangle = ro->getMesh()->getGeometry().m_triangles[*it];
        pickingData.vertices.push_back(ro->getMesh()->getGeometry().m_vertices[triangle[0]]);
        pickingData.vertices.push_back(ro->getMesh()->getGeometry().m_vertices[triangle[1]]);
        pickingData.vertices.push_back(ro->getMesh()->getGeometry().m_vertices[triangle[2]]);
      }
    }
  }

  void LightPathLoader::createSphereSelection(Entity* entity) {
    if (m_sphere == NULL) {
      LightPathPlugin::LightPathComponent* component;
      shared_ptr<Material> material;
      BlinnPhongMaterial* bpMaterial;
      component = new LightPathPlugin::LightPathComponent("SlectionSphere", entity);
      shared_ptr<Mesh> display( new Mesh( "SelectionSphere" ));
      
      sphereData.radius = 0.25;
      display->loadGeometry( MeshUtils::makeParametricSphere( 0.25 ) );

      bpMaterial = new BlinnPhongMaterial( "SelectionSphereMaterial" );
      material.reset( bpMaterial );
      bpMaterial->m_kd = Color( 0.f, 0.5, 0.8, 1.f );
      
      m_sphere =
        RenderObject::createRenderObject("SelectSphereRO", component, RenderObjectType::Fancy, display,
                                         RenderTechnique::createDefaultRenderTechnique(), material );
      component->addRenderObject( m_sphere );
    }
  }

  void LightPathLoader::setSphereRadius(float radius) {
    if (m_sphere != NULL) {
      m_sphere->getMesh()->loadGeometry( MeshUtils::makeParametricSphere( radius ) );
      sphereData.radius = radius;
    }
  }

  void LightPathLoader::switchBetaL(bool value) {
    isBeta = value;
    LOG( logINFO ) << "Path analysis now working on: " << (isBeta ? "Beta" : "L");
  }
  
} // namespace LightPathPlugin
