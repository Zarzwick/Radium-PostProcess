/**
 * \class LightPathLoader
 *
 * \ingroup LightPathPlugin
 *
 * \brief A loading interface of path file using selection by  triangle/multi-triangle or sphere.
 * Then do an 2D FFT for spectrum analysis on the parameter Beta or L of the selected paths.
 *
 * \author Gwendal Patat
 *
 * \date 2018/06/08
 */

#ifndef LIGHTPATHPLUGIN_LOADER_HPP
#define LIGHTPATHPLUGIN_LOADER_HPP

#include <LightPathPlugin.hpp>
#include <LightPathUI.hpp>
#include <PathLoader.hpp>
#include <Engine/Renderer/Renderer.hpp>
#include <Core/Math/LinearAlgebra.hpp>
#include <complex>
#include <fftw3.h>
#include <QImage>

namespace Ra {
  namespace Engine {
    class Entity;
    class RenderObjectManager;
  } // Engine
} // Ra

namespace LightPathPlugin {
  class LightPathLoader : public PathLoader::PathLoaderC {
  public:

    /*!
     *  \brief Constructor
     *
     *  Constructor of the LightPathLoader class
     */
    LightPathLoader(const std::string& fileName,
                    Ra::Engine::RenderObjectManager* ROManager,
                    LightPathUI* widget);
    
    /*!
     *  \brief Destructor
     *
     *  Destructor of the LightPathLoader class
     */
    virtual ~LightPathLoader();
   
    virtual bool isSelected(const pbrt::sample_path_file::PathEntry &path) override;

    /*!
     *  \brief Initialize all the needed variables for the loading
     */
    virtual void preLoadingProcess() override;
    
    virtual void inLoadingProcess(const pbrt::sample_path_file::PathEntry &path) override;
    
    /*!
     *  \brief Compute the FFT image of the data spectrum of the selected paths
     */
    virtual void postLoadingProcess() override;

    /*!
     *  \brief Setup of the picking data using the picking manager result
     *
     *  \param pick : the picking result from the picking manager
     */
    void setPickResult(const Ra::Engine::Renderer::PickingResult pick);

    /*!
     *  \brief Create the selection sphere of the path loader
     *
     *  \param entity : the empty entity for the sphere
     */
    void createSphereSelection(Ra::Engine::Entity* entity);

    /*!
     *  \brief Change the radius of the selection sphere (the object and the data)
     *
     *  \param radius : the new radius
     */
    void setSphereRadius(float radius);

    /*!
     *  \brief Change the parameter that we want to collect from the path
     *
     *  \param value : True = Beta, False = L
     */
    void switchBetaL(bool value);
    
  private:
    /*!
     *  \brief Collect data (Beta or L) from the selected path to fill the dataMatrix
     *
     *  \param path : the selected path
     *  \param rayDir : the direction of the path
     */
    void collectData(const pbrt::sample_path_file::PathEntry &path, Ra::Core::Vector3 rayDir);

    /*!
     *  \brief A 2D FFT
     *
     *  \param f : the input matrix of the 2D FFT
     *  \param F : the output matrix of the 2D FFT
     *  \param width : the width of the matrix
     *  \param height : the height of the matrix
     */
    void fft2D(fftw_complex *f, fftw_complex *F, int width, int height);

    /*!
     *  \brief Perform an absolute fonction (for complex) on the result of an FFT
     *
     *  \param matrix : the input matrix
     *  \param out : the output matrix
     *  \param size : the number of elements
     */
    void fftw_complex_abs(fftw_complex *matrix, double* out, int size);

    /*!
     *  \brief Shift an FFT matrix
     *
     *  \param fft_out : the fft matrix
     *  \param fft_out_shift : the resulting shifted fft matrix
     */
    void fft_shift(double* fft_out, double* fft_out_shift);

    /*!
     *  \brief Make a gray image of the fft, store in QImage* qi
     *
     *  \param fft : the fft matrix
     */
    void fft_image(double *fft);

    /*!
     *  \brief Testing for each segments of a path if there is any intersection with the sphere
     *  or the triangle of the picking data.
     *
     *  \param path : the path to test
     *  \param triVertices : vertices of the triangle (if the selection doesn't use the sphere)
     *  \return bool telling if an intersection was compute
     */
    bool rayCasting(const pbrt::sample_path_file::PathEntry &path,
                    std::array<Ra::Core::Vector3, 3> triVertices);
    
    Ra::Engine::RenderObject* m_sphere = NULL;
    Ra::Engine::RenderObjectManager* m_ROManager;
    LightPathUI* m_widget;

    bool isBeta = true;
    QImage *qi;
    int sizeEdgeImage = 1000;
    int sizeImage = sizeEdgeImage * sizeEdgeImage;
    double* fft_out_shift;
    double* fft_out;
    fftw_complex* dataMatrix;
    fftw_complex* resultMatrix;
    
    struct s_pickingData {
      bool init = false;
      int m_roIdx;
      Ra::Engine::Renderer::PickingMode m_mode;
      std::vector<Ra::Core::Vector3f> vertices;
    } pickingData;
    
    struct s_sphereData {
      float radius;
      Ra::Core::Vector3f center;
    } sphereData;
  };
  
} // namespace LightPathPlugin

#endif // LIGHTPATHPLUGIN_LOADER_HPP
